using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Algorithm : MonoBehaviour
{
}

/*-<프로젝트 생성>-*/
// 1. 2D 프로젝트 생성
// 2. 스프라이트 다운로드
// 3. 플레이어 게임 오브젝트를 씬에 배치

/*--<플레이어 이동>--*/
// 1. 사용자의 입력에 따라 플레이어를 이동시킨다.
//      => 필요속성 : 속력
//      => Inpu.GetAxisRaw()로 입력 받은 방향을 -1, 0 , +1로 받는다.
//      => P = P0 + vt의 공식으로 플레이어를 이동 시킨다.
// 2. 게임 해상도 설정

/*---<플레이어의 이동 경계선 생성>---*/
// 1. 경계선 역활을 할 빈 게임 오브젝트를 생성
// 2. 빈 게임 오브젝트에 Box Collider2D, Rigidbody2D 컴포넌트 부착
// 3. 부착한 Box Collider2D의 속성 중 isTrigger 활성화
// 4. 부착한 Rigidbody2D의 속성 중 Body Type을 static으로 변경( 고정적인 )
// 4. 플레이어 게임 오브젝트에 Box Collider2D, Rigidbody2D 컴포넌트 부착
// 5. Rigidbody2D의 속성 중 Body Type을 Kinematics으로 변경( 스크립트로 구현한 물리 연산만 실행 )

/*----<경계선 설정>----*/
// 1. 플레이어가 경계선에 닿으면 해당 방향 값을 0으로 바꾼다.
//      => 필요속성 : 경계선에 닿았는지 체크할 bool 변수 4개
//      => OnTriggerEnter2D() 함수로 경계선에 닿으면 switch문으로 해당 bool변수를 true로 변경
//      => tag를 통해서 경계선을 구분
//      => 사용자로 부터 방향이 입력될 때 bool변수가 true일 경우 방향 값을 0으로 변경
// 2. 플레이어가 경계선을 벗어나면 정상 이동된다.
//      => OnTriggerExit2D() 함수로 경계선을 벗어나면 switch문으로 해당 bool변수를 false로 변경
// 3. 경계선에 등록할 태그를 생성

/*-----<플레이어 애니메이션 등록>-----*/
// 1. 직진 애니메이션 스프라이트를 플레이어 게임 오브젝트에 등록
// 2. 좌회전 애니메이션 스프라이트를 플레이어 게임 오브젝트에 등록
// 3. 우회전 애니메이션 스프라이트를 플레이어 게임 오브젝트에 등록
// 4. 애니메이터에 진입하여 애니메이션 클립들을 make Transition으로 연결
// 5. int 타입의 파라미터 생성
// 6. 각각의 애니메이션 클립에 파라미터 부착
// 7. 파라미터 속성을 Equal로 설정하고 -1, 0, 1을 각각 지정
// 8. 애니메이션 클립의 속성 중 Exit Time을 비활성화, offset을 0으로 지정
// 9. 플레이어의 움직임에 따라 각기 다른 애니메이션을 출력하고 싶다.
//      => 필요속성 : 애니메이터
//      => Awake()함수를 사용하여 애니메이터에 애니메이터 컴포넌트를 넣는다.
//      => 수평 이동(GetButtonDown, GetButtonUp)을 입력 받는 조건을 만든다.
//      => 애니메이터 컴포넌트의 SetInteger()함수를 이용해 파라미터 값을 전달한다.

/*-<총알 프리팹 생성>-*/
// 1. 총알 게임 오브젝트를 씬에 배치
// 2. Collider2D와 Rigidbody2D 컴포넌트 부착
// 3. isTrigger, 중력 0
// 4. 프리팹 폴더에 애셋화

/*--<총알 경계선 생성>--*/
// 1. 빈 오브젝트를 만들어 총알 경계선을 생성
// 2. 총알 경계선 태그를 만든다.
// 3. 총알이 총알 경계선에 닿으면 총알을 제거하고 싶다.
//      => OnTriggerEnter2D()로 총알이 총알 경계선에 닿을 때 호출
//      => 총알 경계선 태그가 인식되면 총알 제거

/*---<플레이어가 총알을 발사>---*/
// 1. 플레이어가 총알을 발사하고 싶다.
//      => 필요속성 : 총알 프리팹
//      => 총알 발사를 구현하기 전에 플레이어 이동과 관련된 구현은 따로 함수에 저장한다.
//      => 총알 발사 함수를 만들어서 내용을 작성
//      => 총알을 객체화 하여 변수로 저장하고
//      => 리지드바디 컴포넌트를 불러와 AddForce()함수로 발사( 리지드바디 변수를 만들고 그 안에 리지드바디 컴포넌트를 넣는다. )

/*----<총알 기능 추가>----*/
// 1. 발사 버튼을 누르면 총알이 발사된다.
//      => 발사 버튼을 누르고 있지 않으면 return;
// 2. 발사 딜레이를 주고 싶다.
//      => 필요속성 : 발사 시간, 현재 시간
//      => 현재 시간이 추가되는 함수 생성
//      => 현재 시간이 발사 시간보다 작으면 return;
//      => 총알을 발사한 뒤에 현재 시간 초기화

/*-----<총알 종류 추가>-----*/
// 1. 플레이어가 아이템을 먹었다고 가정하고 총알이 바뀌는 상황을 구현하고 싶다.
//      => 필요속성 : 파워 변수
//      => switch문으로 파워의 단계 별로 다르게 총알이 발사되게 한다.
//      => 파워가 하나일 때는 기존 총알 그대로 발사
//      => 파워가 두개일 때는 기본 총알 두 개를 발사
//      => 두 개의 총알이 서로 떨어질 수 있게 거리를 조절
//      => 각기 다른 객체와 rigid변수를 사용하여 발사
//      => 파워가 세개일 때는 특수 총알 한 개를 추가하여 발사

/*-<적 객체 생성>-*/
// 1. 3종류의 적 스프라이트를 게임 씬에 등록한다.
// 2. 오브젝트 모양에 맞는 Collder2D를 부착
// 3. 스프라이트 에디터에 들어가면 custom physic shape 모드를 통해 Collider2D의 모양을 조정할 수 있다.
// 4. 리지드 바디를 부착
// 5. isTrigger, 중력 0
// 6. 태그 추가
// 7. 스크립트 생성 및 부착

/*--<적 프리팹 생성>--*/
// 1. 적의 구성 요소를 구체화 하여 스크립트로 작성
//      => 필요속성 : 속도, 체력, 리지드바디 컴포넌트, 스프라이트 렌더러 변수, 스프라이트 배열
//      => 리지드바디, 스프라이트 렌더러 컴포넌트를 불러온다.
//      => 리지드바디 변수를 통해 속도를 지정한다.
//      => 충돌 했을 때 데미지 받는 기능을 구현
//      => 체력이 다 떨어지면 제거되는 기능을 구현
//      => 스프라이트가 잠깐 바뀌었다 원상 복구하는 기능을 구현
//      => 스프라이트 렌더러 변수를 통해 스프라이트를 바꾼다.
//      => 다시 원상태로 돌려놓기위해 Invoke() 함수를 통해 되돌리는 함수를 호출한다.
//      => 적이 경계선에 닿을 경우 적을 제거하는 OnTriggerEnter2D 함수를 구현한다.
// 2. 총알 태그를 만들어서 총알 프리팹에 부착
//      => 적이 총알에 닿으면 데미지를 전달 받아 체력이 달는다.
//      => 데미지 변수를 총알 스크립트에 작성해 준다.
//      => 총알 컴포넌트를 불러와서 데미지를 전달한다.
// 3. 적 프리팹 마다 속성 값을 지정해 준다.
// 4. 적 프리팹 마다 스프라이트 2개씩 적용해 준다.
//      => 총알이 적에 충돌하면 총알을 제거
// 5. 프리팹 화 한다.
// 6. 프리팹의 위치를 초기화

/*---<적 기체 생성>---*/
// 1. 빈 오브젝트를 만들고 GameManager라 칭한다.
// 2. 스크립트를 만들고 할당한다.
//      => 필요속성 : 적 프리팹 배열, 스폰 포인트, 생성 시간, 현재 시간
//      => 시간을 지속적으로 증가 시킨다.
//      => 현재 시간이 생성 시간 보다 커지면 적 생성 함수를 호출한다.
//      => 적 생성 함수를 만든다.
//      => 적을 생성한 뒤 현재 시간을 초기화 해준다.
//      => 생성 시간을 랜덤하게 바꿔 준다.
//      => 적 생성 함수는 랜덤한 적을 랜덤한 위치에서 생성한다.
// 3. 스폰 포인트를 만들어서 배치한다.

/*-<옆에서 생성되는 적>-*/
// 1. 스폰 포인트를 좌우에 두 개씩 추가 배치한다.
// 2. 옆에서 생성된 적의 이동 방향을 바꾸어 준다.
//      => 공장에서 객체로 만들어진 적을 변수로 저장하고
//      => 적 객체의 리지드바디 + 적 스크립트 컴포넌트를 불러온다.
//      => Vector2를 사용하여 x축은 방향에 따라 -1, +1을 곱해 주고
//      => y축은 서서히 아래로 내려가도록 -1로 지정한다.
// 3. 옆으로 움직이는 적의 스크립트 방향을 재설정 한다.
//      => Rotate()함수를 통해 z축을 바꿔준다.

/*--<적 공격>--*/
// 1. 적 총알 프리팹을 만든다.
// 2. 플레이어 총알의 프리팹을 복사하여 스프라이트만 바꿔준다.
// 3. 총알 모양에 따라 Collider을 바꿔 준다.
// 4. 태그를 추가해 준다.
//      => 필요속성 : 총알 공장, 발사 시간, 현재 시간, 적 이름 변수, 플레이어 변수
//      => 플레이어 총알 발사 함수를 복사해와서 수정한다.
//      => 적 타입에 따라 각기 다른 총알을 발사 한다.
//      => 총알의 방향은 플레이어 - 적 의 위치이다.
//      => 플레이어의 위치를 알아야 한다.
// 5. 게임 매니저 스크립트에서 적의 위치를 찾는다.
//      => 필요속성 : 플레이어 변수
//      => GameManager 스크립트에서 적 공장을 통해 적을 만든다. 이 때 적이라는 객체가 탄생한다.
//      => 여기서 EnemyLogic이라는 변수가 있고 이 변수는 Enemy 스크립트를 컴포넌트로 갖게 된다.
//      => Enemy 스크립트 내부에는 player 변수가 있다.
//      => EnemyLogic의 멤버 변수 player에 접근하여 GameManager에 만들어둔 플레이어 변수를 넘겨준다.
// 6. 다시 Enemy 스크립트로 돌아가서 새로운 방향으로 플레이어 - 적을 만든다.
// 7. 적 프리팹에 할당된 적 이름 변수에 이름을 지정해 준다.
// 8. 벡터의 속도는 방향과 크기가 포함되어 있기 때문에 normalized변수를 통해 크기를 정규화 시킨다.

/*---<피격 이벤트>---*/
// 1. Player 스크립트에 적, 적의 총알과 충돌했을 때 플레이어가 비활성화 되도록 한다.
//      => 비활성화 된 객체는 Invoke()함수가 작동하지 않는다.
//      => 비활성화 된 객체를 다시 활성화 시키는 기능은 GameManager에서 구현 한다.
// 2. GameManager 스크립트에서 플레이어의 위치를 지정해 주고 활성화 시켜주는 함수를 만든다.
//      => Invoke() 함수를 사용하여 활성화 함수를 호출한다.
// 3. Player 스크립트에서 GameManager 변수를 만든다.
//      => 플레이어가 비활성화 되기 전에 GameManger 변수를 통해 활성화 함수를 호출한다.

/*-<목숨과 점수 UI를 배치>-*/
// 1. Player 스크립트에 목숨과 점수 변수를 만든다.
// 2. UI Text 오브젝트를 만든다.
// 3. UI Image 오브젝트 3개를 만든다.
// 4. UI의 앵커를 맞춘 후 위치를 조정한다.
// 5. UI Image에 스프라이트를 부착
// 6. 통합 UI 오브젝트에 Canvas Scaler 컴포넌트의 UI Scale Mode를 Scale With Screen Size로 바꾼다.
// 7. Game Over Text UI 도 만들어 준다.
// 8. UI Button을 만들어 Retry 버튼으로 만들어 준다.
// 9. 버트 스프라이트의 스프라이트 에디터로 진입하여 Border을 설정해 준다.
// 10. Game Over와 Retry버튼의 통합 UI를 비활성화 해둔다.

/*--<UI 로직>--*/
// 1. Player 스크립트에 점수와 생명을 변수로 만든다.
// 2. Enemy 스크립트에서 점수를 플레이어에게 넘겨 준다.
//      => 필요속성 : 적 점수 변수
//      => Enemy 객체가 제거될 때 Player 컴포넌트를 불러와서 점수 변수에 적 점수 변수를 더해 준다.
// 3. GameManager 스크립트에서 Text 변수를 만든다.
//      => 필요속성 : 점수 Text, 생명 Image 배열, GameOver 게임 오브젝트
//      => 실시간으로 플레이어 컴포넌트로 부터 점수를 받아와서 출력 한다.
//      => string.Format("{0:n0}", playerLogic.score);를 통해 숫자 세자리 수마다 콤마를 찍어 준다.
// 4. Player 스크립트에서 적의 촉알에 맞을 때 생명이 소멸되도록 한다.
//      => life 변수를 1 감소 시킨다.
// 5. GameManager 스크립트에서 생명 Image가 하나 지워지는 함수를 만든다.
//      => 반복문을 통해 life 갯수만큼 이미지를 출력한다.
//      => new color(1, 1, 1, 0); new color(1, 1, 1, 1);를 통해 이미지를 출력 한다.
// 6. Player 스크립트에서 GameManager의 생명 함수를 호출하면서 life 변수를 전달한다.
//      => life가 0일 경우 GameManger의 GameOver() 함수를 호출한다.
//      => life가 0이 아닐 경우 유저 재생성 함수 호출
// 7. GameManager 스크립트에서 GameOver 함수를 만든다.
//      => 게임 오버 통합 UI를 true로 활성화 시킨다.
// 8. GameManger 스크립트에서 Retry버튼을 구현한다.
//      => 씬 매니저를 통해 씬을 새롬게 불러올 함수를 만든다.
// 9. 빌드 쎄팅에서 게임 씬을 등록한다.
// 10. Retry 버튼에 GameManger의 함수를 등록 시킨다.

/*---<버그 처리>---*/
// 1. 총알 두 개를 동시에 맞을 때 체력이 두 개 깍이는 버그
// 2. Player 스크립트에서 피격된 상태에서는 추가적인 피격이 않되게 한다.
//      => 필요속성 : 피격 중임을 알릴 bool 변수
//      => 피격 됬을 때 bool 변수가 true 라면 반환
//      => 피격 되었다면 bool 변수를 true로
// 3. GameManager 스크립트에서 피격 변수 bool을 불러와서 플레이어를 다시 태어나게 할 때 false로 

/*-<아이템 배치>-*/
// 1. 아이템 스프라이트를 씬에 배치한다.
// 2. 각각의 아이템 오브젝트에 리지드 바디와 Collider를 부착
// 3. is Trigger, 중력 0
// 4. 아이템 스크립트를 만들고 부착
//      => 필요속성 : 아이템 종류를 구분하기 위한 public string 클래스의 변수, 리지드바디
//      => Awake()함수를 통해 rigid변수를 초기화 하고 속도를 지정해 준다.
// 5. 씬에서 아이템 별로 아이템 타입을 string 타입으로 작성한다.
// 6. 애니메이션 클립을 각각의 게임 오브젝트에 부착한다.
// 7. 아이템 태크 만들기

/*--<충돌 처리>--*/
// 1. 플레이어 스크립트에서 아이템 충돌을 구현한다.
//      => 아이템 컴포넌트를 받아온다.
//      => switch문으로 아이템의 타입을 구분한다.
//      => 동전을 먹으면 점수를 추가로 더한다.
//      => 파워를 먹으면 플레이어의 파워가 증가한다.
//      => 단, 파워가 max일 때 추가로 증가하면 않되기 때문에 maxPower라는 변수를 추가로 만든다.

/*---<필살기>---*/
// 1. 폭탄 스프라이트의 크기를 조정한다.
// 2. 스프라이트 배치
// 3. order layer를 통해 다른 오브젝트보다 밑에 있게 지정한다.
// 4. 애니메이션 클립을 오브젝트에 부착한다.
// 5. 애니메이터에서 속도를 조절
// 6. 비활성화
// 7. 플레이어 스크립트에서 폭탄 변수를 만든다.
// 8. 폭탄 변수에 폭탄 오브젝트를 연결한다.
// 9. 플레이어가 폭탄 아이템과 충돌하면 폭탄 오브젝트를 활성화
//      => 게임 화면상에 있는 모든 적 오브젝트를 제거한다.
//      => 배열로 적 오브젝트를 불러 온다.
//      => FindGameObjectsTag() 함수를 통해 Enemy 태그가 부착된 게임 오브젝트를 찾아온다.
//      => for문으로 게임 화면에 있는 적 오브젝트를 순회한다.
//      => Enemy변수를 만들어서 Enemy 컴포넌트를 부착한다.
//      => 에너미 변수에 데미지를 전달한다.
// 10. Enemy 스크립트의 OnHit() 함수를 public으로 바꾸어 준다.
// 11. 게임 화면상의 모든 적 총알을 제거한다.
//      => FindGameObjectsTag() 함수를 통해 EnemyBullet 태그라 부착된 게임 오브젝트를 찾아 온다.
//      => 찾아온 게임 오브젝트를 순회 한다.
//      => 제거
// 12. 폭탄이 비활성화 되는 함수를 만든다.
// 13. 폭탄이 활성화 된 후 Invoke() 함수를 통해 비활성화 시킨다.
// 14. 충돌된 아이템도 지워준다.
// 15. 폭탄 아이템을 먹으면 바로 사용되는 것이 아니라 버튼 클릭을 통해 사용한다.
//      => 플레이어 스크립트에 폭탄 갯수 변수를 만든다.
//      => 폭탄 함수를 만든다.
//      => 폭탄이 활성화 상태인지 확인할 bool타입 변수를 만든다.
//      => 버튼을 누르지 않거나 이미 폭탄이 활성화 중이라면 return
//      => switch 문에 나열 하였던 Boom 카테고리의 내용을 옮긴다.
//      => 폭탄 갯수가 0이면 return
//      => 사용하면 폭탄 갯수 --
//      => switch문에서 폭탄 갯수가 max일 경우 점수로 전환
//      => 폭탄을 비활성화 시키는 함수에서 폭탄이 사용 중인지 확인하는 bool타입 변수도 false로 바꿔준다.
//      => 반대로 폭인 사용될 때는 bool 타입 변수를 true로 바꿔준다.
// 16. 폭탄 UI를 만들어 준다.
// 17. 폭탄 UI의 알파 값을 0으로 지정한다.
// 18. 게임 메니저 스크립트에서 배열로 폭탄 UI를 Image 타입으로 불러온다.
//      => Life 이미지를 호출하는 함수를 복붙하여 이름만 바꿔준다.
// 19. 플레이어 스크립트로 돌아가서 아이템을 먹었을 때 BoomUI를 출력하는 함수를 호출한다.
// 20. 폭탄을 사용했을 때 또 한 번 호출한다.

/*----<아이템 드랍>----*/
// 1. 아이템들을 프리팹으로 만든다.
// 2. 에너미 스크립트에서 아이템 공장을 불러온다.
//      => 에너미의 체력이 모두 달았을 때 아이템을 생성한다.
//      => 랜덤하게 아이템이 생성된다.
//      => 랜덤 변수를 만든다.
//      => 저장된 랜덤 값에 따라 아이템이 생성된다.
//      => 에너미가 제거되기 전에 두발 이상을 맞을 경우 아이템이 두 개 이상 생성될 때가 있다.
//      => 에너미의 체력이 이미 0보다 낮다면 return

/*-<배경 배치>-*/
// 1. 3개의 그룹을 빈 게임 오브젝트로 만들고
// 2. 타입 별로 각각 3개씩 집어 넣는다.
// 3. 각기 다른 위치를 지정해 준다.
// 4. 스크립트를 만들고 그룹에 부착한다.
// 5. 현재 위치와 미래 위치를 더해서 아래로 움직이게 한다.
//      => 속도를 public 속성으로 지정해 둔다.
// 6. 배경을 루프 시킨다.
//      => 필요속성 : 시작 인덱스, 끝 인덱스, Transform타입의 배경 배열
//      => 배경이 지속적으로 움직이는 중
//      => endIndex에 위치한 배경의 y축이 범위를 넘어갈 경우
//      => 해당 인덱스의 배경을 위로 올려 준다.
//      => 여기서 해당 인덱스의 position은 글로벌 기준이기 때문에 지역 위치로 바꿔야 한다.
//      => 그룹안에서 이동하기 때문에 localPosition으로 위치를 바꿔준다.
//      => startIndex바로 위에 배치해 준다.
//      => 이를 위해 Vector3 변수를 만들어서 endIndex와 startIndex의 localPosition을 저장해 둔다.
//      => Vector3.up변수를 통해 더하기로 위치를 바꿔준다.
//      => 더하는 값은 카메라 사이즈 값의 두 배로 지정한다.
//      => 해상도에 따라 다른 값이 저장되는 것이 거슬린다면 변수를 만들어서 카메라 사이즈를 가저온다.
//      => endIndex가 가장 위로 올라갔으니 startIndex에 endIndex를 배정
//      => startIndex의 바로 앞 인덱스를 endIndex로 배정
// 7. startIndex와 endIndex값을 지정해 주고
// 8. 배경 이미지를 등록해 준다.

/*--<원근감 조정>--*/
// 1. 가까이에 있는 배경은 빠르게
// 2. 멀리 있는 배경은 느리게 속도를 조정해 준다.
// 3. Move() 와 Scrolling() 함수로 구현한 명령어를 나누어 준다.

/*-<오브젝트 풀>-*/
// 1. 빈 게임 오브젝트를 만든다.
// 2. 오브젝트 매니저 스크립트를 만들고 부착
//      => 프리팹 폴더에 있는 공장들을 배열 형태로 선언
//      => Awake() 함수를 통해 각각 배열의 크기를 초기화
//      => 객체를 만들 함수를 만들고
//      => 모든 프리팹을 각각 객체화 하여 배열에 넣는다.
//      => 만들어진 객체는 만들어 짐과 동시에 비활성화 시킨다.
//      => 게임 오브젝트 타입을 반환하는 함수를 public으로 만든다.
//      => 매개 변수로 스트링 타입의 문장을 받는다.
//      => 게임 오브젝트 타입의 임시 배열을 만든다.
//      => switch문에 따라서 호출된 프리팹의 배열을 반환한다.
//      => 프리팹이 비 활성화 상태인지 확인하고 반환하기 전에 활성화 하여 반환한다.
//      => 만약 비 활성화 된 객체가 없다면 null반환

/*--<풀 사용>--*/
// 1. 게임 매니저 스크립트에서 에너미를 만드는 부분을 수정한다.
//      => 필요속성 : 오브젝트 매니저 public 변수
//      => 오브젝트 매니저의 프리팹 호출 함수는 매개 변수로 스트링을 받는다.
//      => 때문에 게임 메니저의 변수인 적 공장의 타입을 스트링으로 바꿔 준다.
//      => 생성된 객체는 따로 위치와 방향을 지정해 준다.
// 2. 파괴되는 게임 오브젝트를 비활성화로 바꿔 준다.
// 3. 플레이어 스크립트의 총알 생성 과정도 오브젝트 매니저에서 호출하는 방식으로 바꿔준다.
//      => 마찬가지로 위치는 따로 지정한다.
// 4. 에너미 스크립트에 오브젝트 매니저 타입의 변수를 만들고
// 5. 게임 매니저 스크립트에서 오브젝트 매니저 컴포넌트를 에너미 로직에 넘겨 준다.
// 6. 에너미 스크립트의 총알도 같은 방식으로 바꿔준다.
//      => 아이템 생성도 같은 방식으로 바꿔 준다.

/*---<로직 정리>---*/
// 1. 적의 체력이 다 떨어저 비활성화 될 때 Quaternion.identity로 rotation 값을 초기화 시켜준다.
//      => 이 외에 적이 비활성화 되는 모든 때에 같은 방식으로 rotation값을 초기화 시켜준다.
// 2. 체력이 다 떨어져 비활성화 된 적이 다시 활성화 될 때에는 체력을 초기화 시켜준다.
//      => 컴포넌트가 활성화 될 때만 호출되는 OnEnable() 함수를 생성한다.
//      => 적 이름을 switch로 지정하여 체력을 초기화 해준다.
// 3. 아이템도 다시 활성화 될 때 OnEnable() 함수를 사용한다.
//      => 아이템의 속도를 OnEnable() 함수로 옮긴다.
// 4. Find를 통해 오브젝트를 찾는 명령어를 바꿔준다.
// 5. 폭탄 발사시에 Enemy태그와 EnemyBullet태그가 붙은 게임 오브젝트를 찾는 명령어를 바꾼다.
//      => 오브젝트 매니저에 게임 오브젝트 배열을 반환하는 새로운 public 함수를 만든다.
//      => 매개 변수로 오브젝트 이름을 스트링으로 받는다.
//      => switch문으로 해당 오브젝트 배열을 반환한다.
//      => 플레이어 스크립트에서 모든 에너미 프리팹 배열을 받고
//      => 각각 반복문을 통해 활성화된 에너미만 데미지를 입힌다.
//      => 총알도 같은 방식으로 바꾼다.

/*-<스테이지 만들기>-*/
// 1. 적이 생성되는 패턴에는 세가지 변수가 존재한다.
//      => 적 종류, 생성 지점, 생성 시간
// 2. spawn 이라는 이름의 스크립트를 만든다.
//      => start(), update(), Monobehavior 모두 필요 없다.
//      => public 속성으로 float 타입의 시간, string 타입의 이름, int 타입의 스폰 포인트를 선언한다.
// 3. 메모장을 연다.
//      => ,로 구분하여 순서대로 값을 입력하고 줄 바꿈으로 다음 스폰을 입력한다.
// 4. 게임 씬에서 Resources 폴더를 새롬게 만든다.
// 5. 메모장을 드래그 드롭한다.
// 6. GameManager에서 메모작을 읽고 리스트로 만들어서 하나씩 스폰
//      => 파일을 읽는 함수를 만든다.
//      => spawn 타입의 리스트를 만들고
//      => spawn 리스트의 인덱스
//      => spawn이 모두 끝났는지 체크할 bool 변수를 만든다.
//      => Awake() 함수로 리스트를 초기화 해준다.
//      => 파일을 읽기 전에 리스트를 모두 지워주고, 인덱스를 0, bool을 false로 초기화 해준다.
//      => System.IO
//      => TextAsset 클래스의 객체를 만들고 Resources폴더의 메모장을 불러 온다.
//      => 불러올때 메모장의 이름을 매개 변수로 전달하고 해당 파일이 텍스트 파일인지 확인한다.
//      => StringReader 클래스를 통해 메모장을 읽는다.
//      => StringReader클래스의 멤버 함수인 ReadLine()를 통해 한 줄씩 저장한다.
//      => 구조체 변수로 저장한다. Split(',')멤버 함수를 통해 구분하여 저장한다.
//      => 구조체 변수를 리스트에 저장한다.
//      => StringReader로 다 읽을 때 까지 반복한다.
//      => 읽은 한 줄이 null일 경우 반복문 탈출
//      => 다 읽은 뒤 파일을 닫는다.
//      => 스테이지의 첫 번째 딜레이를 지정해 준다.
// 7. 파일은 Awake()에서 초기화가 다 끝난 뒤에 읽는다.

/*--<데이터 적용>--*/
// 1. 게임 매니저에서 랜덤 스폰과 랜덤 종류를 바꿔준다.
//      => 적을 생성하는 함수에서 switch문을 통해 메모장의 스트링을 인트로 바꿔준다.
//      => 그러기 위해 int 타입의 변수를 만든다.
//      => 스폰 포인트또한 메모장에서 불러온다.
//      => 다 소환한 뒤 리스트 인덱스를 증가 시킨다.
//      => 전부 생성 했다면 bool 타입 변수를 true로 바꿔주고 return;
//      => 다음 리스폰 딜레이를 갱신한다.
//      => Update() 함수에 있는 적 생성 조건에 bool 타입 변수가 true인지 확인하는 것을 추가한다.